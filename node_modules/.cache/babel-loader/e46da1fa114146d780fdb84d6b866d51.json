{"ast":null,"code":"import _classCallCheck from \"/Users/kristinatong/projects/sound-motion/sound-motion-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kristinatong/projects/sound-motion/sound-motion-frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kristinatong/projects/sound-motion/sound-motion-frontend/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kristinatong/projects/sound-motion/sound-motion-frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kristinatong/projects/sound-motion/sound-motion-frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/kristinatong/projects/sound-motion/sound-motion-frontend/src/components/Video.js\";\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux'; // import * as actions from '../redux/actions';\n// import { changeSprite } from '../actions/sprite'\n// import Konva from 'konva';\n\nimport { Stage, Layer } from 'react-konva';\nimport SpriteList from './SpriteList';\nimport ControlBar from './ControlBar';\nimport UploadSound from './UploadSound';\nimport { DiffCamEngine } from './diff-cam-engine'; // import * from './adapter-1.0.7'\n\nvar stream; // stream obtained from webcam\n\nvar video; // shows stream\n\nvar captureCanvas; // internal canvas for capturing full images from video\n\nvar captureContext; // context for capture canvas\n\nvar diffCanvas; // internal canvas for diffing downscaled captures\n\nvar diffContext; // context for diff canvas\n\nvar motionCanvas; // receives processed diff images\n\nvar motionContext; // context for motion canvas\n\nvar initSuccessCallback; // called when init succeeds\n\nvar initErrorCallback; // called when init fails\n\nvar startCompleteCallback; // called when start is complete\n\nvar captureCallback; // called when an image has been captured and diffed\n\nvar captureInterval; // interval for continuous captures\n\nvar captureIntervalTime; // time between captures, in ms\n\nvar captureWidth; // full captured image width\n\nvar captureHeight; // full captured image height\n\nvar diffWidth; // downscaled width for diff/motion\n\nvar diffHeight; // downscaled height for diff/motion\n\nvar isReadyToDiff; // has a previous capture been made to diff against?\n\nvar pixelDiffThreshold; // min for a pixel to be considered significant\n\nvar scoreThreshold; // min for an image to be considered significant\n\nvar includeMotionBox; // flag to calculate and draw motion bounding box\n\nvar includeMotionPixels; // flag to create object denoting pixels with motion\n\nvar coords;\nvar testContext;\nvar test;\nvar spritePositionX;\nvar spritePositionY;\n\nvar Video =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Video, _Component);\n\n  function Video() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Video);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Video)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.state = {\n      x: 0,\n      y: 0,\n      // bottom: 0,\n      height: 0,\n      left: 0,\n      // right: 0,\n      top: 0,\n      width: 0,\n      stream: null // captureInterval: null,\n      // video: document.getElementById('video'),\n      // motionCanvas : document.createElement('canvas'),\n      // captureIntervalTime: 100,\n      // captureWidth: 640,\n      // captureHeight: 480,\n      // diffWidth: 64,\n      // diffHeight: 48,\n      // pixelDiffThreshold: 32,\n      // scoreThreshold: 16,\n      // includeMotionBox: false,\n      // includeMotionPixels: false,\n\n    };\n\n    _this.initSuccess = function (requestedStream) {\n      console.log(requestedStream);\n      stream = requestedStream;\n\n      _this.setState({\n        stream: stream\n      }); // console.log(initSuccessCallback)\n      // initSuccessCallback();\n\n\n      _this.start();\n    };\n\n    _this.start = function () {\n      // video = document.getElementById('video');\n      video = document.createElement('video');\n      video.autoplay = true;\n\n      if (!stream) {\n        throw 'Cannot start after init fail';\n      } // streaming takes a moment to start\n\n\n      video.addEventListener('canplay', _this.startComplete);\n      video.srcObject = stream;\n    };\n\n    _this.startComplete = function () {\n      video.removeEventListener('canplay', _this.startComplete);\n      captureInterval = setInterval(_this.capture, captureIntervalTime);\n    };\n\n    _this.stop = function () {\n      clearInterval(captureInterval); // video.src = '';\n      // motionContext.clearRect(0, 0, diffWidth, diffHeight);\n\n      testContext.clearRect(0, 0, diffWidth, diffHeight);\n      isReadyToDiff = false;\n\n      _this.state.stream.getVideoTracks()[0].stop();\n    };\n\n    _this.drawSprites = function () {\n      if (_this.props.canvasSprites) {\n        _this.props.canvasSprites.map(function (sprite) {\n          var image = new window.Image();\n          image.src = sprite.sprite.url;\n\n          image.onload = function () {\n            testContext.save(); // testContext.scale(-1,1)\n            // testContext.drawImage(image, sprite.position.x-test.width+60, sprite.position.y, -60, 60)\n\n            testContext.drawImage(image, sprite.position.x, sprite.position.y, 60, 60);\n            testContext.restore();\n          };\n        });\n      }\n    };\n\n    _this.capture = function () {\n      // save a full-sized copy of capture\n      captureContext.drawImage(video, 0, 0, captureWidth, captureHeight);\n      var captureImageData = captureContext.getImageData(0, 0, captureWidth, captureHeight);\n      testContext.drawImage(video, 0, 0, captureWidth, captureHeight);\n\n      _this.drawSprites(); // diff current capture over previous capture, leftover from last time\n\n\n      diffContext.globalCompositeOperation = 'difference';\n      diffContext.drawImage(video, 0, 0, diffWidth, diffHeight);\n      var diffImageData = diffContext.getImageData(0, 0, diffWidth, diffHeight); // console.log('diffImageData',diffImageData)\n\n      if (isReadyToDiff) {\n        var diff = _this.processDiff(diffImageData);\n\n        motionContext.putImageData(diffImageData, 0, 0);\n\n        if (diff.motionBox) {\n          motionContext.strokeStyle = '#fff';\n          motionContext.strokeRect(diff.motionBox.x.min + 0.5, diff.motionBox.y.min + 0.5, diff.motionBox.x.max - diff.motionBox.x.min, diff.motionBox.y.max - diff.motionBox.y.min);\n        }\n\n        captureCallback({\n          imageData: captureImageData,\n          score: diff.score,\n          hasMotion: diff.score >= scoreThreshold,\n          motionBox: diff.motionBox,\n          motionPixels: diff.motionPixels,\n          getURL: function getURL() {\n            return this.getCaptureUrl(this.imageData);\n          },\n          checkMotionPixel: function checkMotionPixel(x, y) {\n            return this.checkMotionPixel(this.motionPixels, x, y);\n          }\n        });\n      } // draw current capture normally over diff, ready for next time\n\n\n      diffContext.globalCompositeOperation = 'source-over';\n      diffContext.drawImage(video, 0, 0, diffWidth, diffHeight);\n      isReadyToDiff = true;\n    };\n\n    _this.playSound = function () {};\n\n    return _this;\n  }\n\n  _createClass(Video, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var spriteCanvas = document.getElementsByClassName('konvajs-content')[0].getBoundingClientRect();\n      this.setState({\n        x: spriteCanvas.x,\n        y: spriteCanvas.y,\n        // bottom: spriteCanvas.bottom,\n        height: spriteCanvas.height,\n        left: spriteCanvas.left,\n        // right: spriteCanvas.right,\n        top: spriteCanvas.top,\n        width: spriteCanvas.width // captureWidth: spriteCanvas.width,\n        // captureHeight: spriteCanvas.height,\n\n      });\n      motionCanvas = this.refs.motion;\n      test = this.refs.test; // prep video\n      // non-configurable\n\n      captureCanvas = document.createElement('canvas');\n      diffCanvas = document.createElement('canvas');\n      isReadyToDiff = false; // prep capture canvas\n\n      captureWidth = spriteCanvas.width;\n      captureHeight = spriteCanvas.height;\n      captureCanvas.width = captureWidth;\n      captureCanvas.height = captureHeight;\n      captureContext = captureCanvas.getContext('2d'); // prep diff canvas\n\n      diffWidth = 64;\n      diffHeight = 48;\n      diffCanvas.width = diffWidth;\n      diffCanvas.height = diffHeight;\n      diffContext = diffCanvas.getContext('2d'); // prep motion canvas\n\n      motionCanvas.width = diffWidth;\n      motionCanvas.height = diffHeight;\n      motionContext = motionCanvas.getContext('2d'); //test canvas\n\n      test.width = diffWidth;\n      test.height = diffHeight;\n      testContext = test.getContext('2d');\n      captureIntervalTime = 100;\n      pixelDiffThreshold = 32;\n      scoreThreshold = 16;\n      includeMotionBox = false;\n      includeMotionPixels = false;\n\n      captureCallback = function captureCallback() {};\n\n      this.requestWebcam();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.stop();\n    }\n  }, {\n    key: \"requestWebcam\",\n    value: function requestWebcam() {\n      var constraints = {\n        audio: false,\n        video: {\n          width: captureWidth,\n          height: captureHeight\n        }\n      };\n      navigator.mediaDevices.getUserMedia(constraints).then(this.initSuccess).catch(this.initError);\n    }\n  }, {\n    key: \"initError\",\n    value: function initError(error) {\n      console.log(error);\n      alert('Something went wrong.');\n    }\n  }, {\n    key: \"processDiff\",\n    value: function processDiff(diffImageData) {\n      var rgba = diffImageData.data; // pixel adjustments are done by reference directly on diffImageData\n\n      var score = 0;\n      var motionPixels = includeMotionPixels ? [] : undefined;\n      var motionBox = undefined;\n\n      for (var i = 0; i < rgba.length; i += 4) {\n        var pixelDiff = rgba[i] * 0.3 + rgba[i + 1] * 0.6 + rgba[i + 2] * 0.1;\n        var normalized = Math.min(255, pixelDiff * (255 / pixelDiffThreshold));\n        rgba[i] = 0;\n        rgba[i + 1] = normalized;\n        rgba[i + 2] = 0;\n\n        if (pixelDiff >= pixelDiffThreshold) {\n          score++;\n          coords = this.calculateCoordinates(i / 4);\n          console.log('coords', coords, 'pixelDiff', pixelDiff, 'i', i);\n          this.props.canvasSprites.map(function (sprite) {\n            if (sprite.position.x === 0) {\n              spritePositionX = 0;\n            } else {\n              spritePositionX = sprite.position.x * diffWidth / 600;\n            }\n\n            if (sprite.position.y === 0) {\n              spritePositionY = 0;\n            } else {\n              spritePositionY = sprite.position.y * diffHeight / 450;\n            }\n\n            console.log('spritePositionX', spritePositionX, 'sprite.position.x', sprite.position.x);\n            console.log('spritePositionY', spritePositionY, 'sprite.position.y', sprite.position.y);\n\n            if (coords.x >= spritePositionX && coords.x <= spritePositionX + 10) {\n              if (coords.y >= spritePositionY && coords.y <= spritePositionY + 6) {\n                console.log('%c TOUCHED IT ', 'color: red');\n\n                if (document.getElementById(sprite.uniqueKey)) {\n                  var player = document.getElementById(sprite.uniqueKey);\n                  player.paused ? player.play() : player.pause();\n                }\n              }\n            }\n          }); // if (includeMotionBox) {\n          //   motionBox = this.calculateMotionBox(motionBox, coords.x, coords.y);\n          // }\n          //\n          // if (includeMotionPixels) {\n          //   motionPixels = this.calculateMotionPixels(motionPixels, coords.x, coords.y, pixelDiff);\n          // }\n        }\n      }\n\n      return {\n        score: score,\n        motionBox: score > scoreThreshold ? motionBox : undefined,\n        motionPixels: motionPixels\n      };\n    }\n  }, {\n    key: \"calculateCoordinates\",\n    value: function calculateCoordinates(pixelIndex) {\n      return {\n        x: pixelIndex % diffWidth,\n        // y: Math.floor(pixelIndex / diffWidth)\n        y: Math.floor(pixelIndex / diffWidth)\n      };\n    }\n  }, {\n    key: \"calculateMotionBox\",\n    value: function calculateMotionBox(currentMotionBox, x, y) {\n      // init motion box on demand\n      var motionBox = currentMotionBox || {\n        x: {\n          min: coords.x,\n          max: x\n        },\n        y: {\n          min: coords.y,\n          max: y\n        }\n      };\n      motionBox.x.min = Math.min(motionBox.x.min, x);\n      motionBox.x.max = Math.max(motionBox.x.max, x);\n      motionBox.y.min = Math.min(motionBox.y.min, y);\n      motionBox.y.max = Math.max(motionBox.y.max, y);\n      return motionBox;\n    }\n  }, {\n    key: \"calculateMotionPixels\",\n    value: function calculateMotionPixels(motionPixels, x, y, pixelDiff) {\n      motionPixels[x] = motionPixels[x] || [];\n      motionPixels[x][y] = true;\n      return motionPixels;\n    }\n  }, {\n    key: \"getCaptureUrl\",\n    value: function getCaptureUrl(captureImageData) {\n      // may as well borrow captureCanvas\n      captureContext.putImageData(captureImageData, 0, 0);\n      return captureCanvas.toDataURL();\n    }\n  }, {\n    key: \"checkMotionPixel\",\n    value: function checkMotionPixel(motionPixels, x, y) {\n      return motionPixels && motionPixels[x] && motionPixels[x][y];\n    }\n  }, {\n    key: \"getPixelDiffThreshold\",\n    value: function getPixelDiffThreshold() {\n      return pixelDiffThreshold;\n    }\n  }, {\n    key: \"setPixelDiffThreshold\",\n    value: function setPixelDiffThreshold(val) {\n      pixelDiffThreshold = val;\n    }\n  }, {\n    key: \"getScoreThreshold\",\n    value: function getScoreThreshold() {\n      return scoreThreshold;\n    }\n  }, {\n    key: \"setScoreThreshold\",\n    value: function setScoreThreshold(val) {\n      scoreThreshold = val;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      console.log('VIDEO PROPS', this.props);\n      console.log('VIDEO STATE', this.state);\n      var videoStyle = {\n        top: 0,\n        left: 0,\n        position: 'absolute',\n        zIndex: 4 // background: 'gray',\n\n      };\n      var motionStyle = {\n        top: this.state.top,\n        left: this.state.left,\n        position: 'absolute',\n        zIndex: -1 // background: 'gray',\n\n      };\n      var testStyle = {\n        top: this.state.top,\n        left: this.state.left,\n        position: 'absolute',\n        zIndex: 4,\n        background: 'black',\n        transform: 'rotateY(180deg)',\n        WebkitTransform: 'rotateY(180deg)',\n        MozTransform: 'rotateY(180deg)'\n      };\n      return React.createElement(\"div\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 417\n        },\n        __self: this\n      }, React.createElement(\"video\", {\n        id: \"video\",\n        style: videoStyle,\n        width: this.state.width,\n        height: this.state.height,\n        ref: \"video\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 418\n        },\n        __self: this\n      }), React.createElement(\"canvas\", {\n        id: \"motion\",\n        style: motionStyle,\n        width: this.state.width,\n        height: this.state.height,\n        ref: \"motion\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 419\n        },\n        __self: this\n      }), React.createElement(\"canvas\", {\n        id: \"test\",\n        style: testStyle,\n        width: this.state.width,\n        height: this.state.height,\n        ref: \"test\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 420\n        },\n        __self: this\n      }), React.createElement(\"span\", {\n        id: \"score\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 421\n        },\n        __self: this\n      }), React.createElement(\"script\", {\n        src: \"https://webrtc.github.io/adapter/adapter-1.0.7.js\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 422\n        },\n        __self: this\n      }));\n    }\n  }]);\n\n  return Video;\n}(Component);\n\nfunction mapStateToProps(state) {\n  return {\n    canvasSprites: state.sprite.canvasSprites,\n    stopVideo: state.sound.stopVideo\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {};\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Video);","map":{"version":3,"sources":["/Users/kristinatong/projects/sound-motion/sound-motion-frontend/src/components/Video.js"],"names":["React","Component","connect","Stage","Layer","SpriteList","ControlBar","UploadSound","DiffCamEngine","stream","video","captureCanvas","captureContext","diffCanvas","diffContext","motionCanvas","motionContext","initSuccessCallback","initErrorCallback","startCompleteCallback","captureCallback","captureInterval","captureIntervalTime","captureWidth","captureHeight","diffWidth","diffHeight","isReadyToDiff","pixelDiffThreshold","scoreThreshold","includeMotionBox","includeMotionPixels","coords","testContext","test","spritePositionX","spritePositionY","Video","state","x","y","height","left","top","width","initSuccess","requestedStream","console","log","setState","start","document","createElement","autoplay","addEventListener","startComplete","srcObject","removeEventListener","setInterval","capture","stop","clearInterval","clearRect","getVideoTracks","drawSprites","props","canvasSprites","map","sprite","image","window","Image","src","url","onload","save","drawImage","position","restore","captureImageData","getImageData","globalCompositeOperation","diffImageData","diff","processDiff","putImageData","motionBox","strokeStyle","strokeRect","min","max","imageData","score","hasMotion","motionPixels","getURL","getCaptureUrl","checkMotionPixel","playSound","spriteCanvas","getElementsByClassName","getBoundingClientRect","refs","motion","getContext","requestWebcam","constraints","audio","navigator","mediaDevices","getUserMedia","then","catch","initError","error","alert","rgba","data","undefined","i","length","pixelDiff","normalized","Math","calculateCoordinates","getElementById","uniqueKey","player","paused","play","pause","pixelIndex","floor","currentMotionBox","toDataURL","val","videoStyle","zIndex","motionStyle","testStyle","background","transform","WebkitTransform","MozTransform","mapStateToProps","stopVideo","sound","mapDispatchToProps","dispatch"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport { connect } from 'react-redux';\n// import * as actions from '../redux/actions';\n// import { changeSprite } from '../actions/sprite'\n// import Konva from 'konva';\nimport { Stage, Layer } from 'react-konva';\nimport SpriteList from './SpriteList'\nimport ControlBar from './ControlBar'\nimport UploadSound from './UploadSound'\nimport { DiffCamEngine } from './diff-cam-engine'\n// import * from './adapter-1.0.7'\n\n  let stream;\t\t\t\t\t// stream obtained from webcam\n\tlet video;\t\t\t\t\t// shows stream\n\tlet captureCanvas;\t\t\t// internal canvas for capturing full images from video\n\tlet captureContext;\t\t\t// context for capture canvas\n\tlet diffCanvas;\t\t\t\t// internal canvas for diffing downscaled captures\n\tlet diffContext;\t\t\t// context for diff canvas\n\tlet motionCanvas;\t\t\t// receives processed diff images\n\tlet motionContext;\t\t\t// context for motion canvas\n\n\tlet initSuccessCallback;\t// called when init succeeds\n\tlet initErrorCallback;\t\t// called when init fails\n\tlet startCompleteCallback;\t// called when start is complete\n\tlet captureCallback;\t\t// called when an image has been captured and diffed\n\n\tlet captureInterval;\t\t// interval for continuous captures\n\tlet captureIntervalTime;\t// time between captures, in ms\n\tlet captureWidth;\t\t\t// full captured image width\n\tlet captureHeight;\t\t\t// full captured image height\n\tlet diffWidth;\t\t\t\t// downscaled width for diff/motion\n\tlet diffHeight;\t\t\t\t// downscaled height for diff/motion\n\tlet isReadyToDiff;\t\t\t// has a previous capture been made to diff against?\n\tlet pixelDiffThreshold;\t\t// min for a pixel to be considered significant\n\tlet scoreThreshold;\t\t\t// min for an image to be considered significant\n\tlet includeMotionBox;\t\t// flag to calculate and draw motion bounding box\n\tlet includeMotionPixels;\t// flag to create object denoting pixels with motion\n  let coords;\n  let testContext;\n  let test;\n  let spritePositionX;\n  let spritePositionY;\n\nclass Video extends Component {\n  state = {\n    x: 0,\n    y: 0,\n    // bottom: 0,\n    height: 0,\n    left: 0,\n    // right: 0,\n    top: 0,\n    width: 0,\n    stream: null\n    // captureInterval: null,\n    // video: document.getElementById('video'),\n    // motionCanvas : document.createElement('canvas'),\n    // captureIntervalTime: 100,\n    // captureWidth: 640,\n    // captureHeight: 480,\n    // diffWidth: 64,\n    // diffHeight: 48,\n    // pixelDiffThreshold: 32,\n    // scoreThreshold: 16,\n    // includeMotionBox: false,\n    // includeMotionPixels: false,\n  }\n\n  componentDidMount() {\n    let spriteCanvas = document.getElementsByClassName('konvajs-content')[0].getBoundingClientRect()\n\n\n    this.setState({\n      x: spriteCanvas.x,\n      y: spriteCanvas.y,\n      // bottom: spriteCanvas.bottom,\n      height: spriteCanvas.height,\n      left: spriteCanvas.left,\n      // right: spriteCanvas.right,\n      top: spriteCanvas.top,\n      width: spriteCanvas.width,\n      // captureWidth: spriteCanvas.width,\n      // captureHeight: spriteCanvas.height,\n    })\n\n    motionCanvas = this.refs.motion\n    test = this.refs.test\n\n    // prep video\n\n    // non-configurable\n    captureCanvas = document.createElement('canvas');\n    diffCanvas = document.createElement('canvas');\n    isReadyToDiff = false;\n\n    // prep capture canvas\n    captureWidth= spriteCanvas.width;\n    captureHeight= spriteCanvas.height;\n    captureCanvas.width = captureWidth;\n    captureCanvas.height = captureHeight;\n    captureContext = captureCanvas.getContext('2d');\n\n    // prep diff canvas\n    diffWidth= 64;\n    diffHeight= 48;\n    diffCanvas.width = diffWidth;\n    diffCanvas.height = diffHeight;\n    diffContext = diffCanvas.getContext('2d');\n\n    // prep motion canvas\n    motionCanvas.width = diffWidth;\n    motionCanvas.height = diffHeight;\n    motionContext = motionCanvas.getContext('2d');\n\n    //test canvas\n    test.width = diffWidth;\n    test.height = diffHeight;\n    testContext = test.getContext('2d')\n\n    captureIntervalTime= 100;\n\n    pixelDiffThreshold= 32;\n    scoreThreshold= 16;\n    includeMotionBox= false;\n    includeMotionPixels= false;\n\n    captureCallback = function() {};\n    this.requestWebcam();\n  }\n\n  componentWillUnmount(){\n\n    this.stop()\n  }\n\n  requestWebcam() {\n    let constraints = {\n      audio: false,\n      video: {\n        width: captureWidth,\n        height: captureHeight\n      }\n    };\n\n    navigator.mediaDevices.getUserMedia(constraints)\n      .then(this.initSuccess)\n      .catch(this.initError);\n  }\n\n  initSuccess = (requestedStream) => {\n    console.log(requestedStream)\n    stream = requestedStream\n    this.setState({\n      stream: stream\n    })\n    // console.log(initSuccessCallback)\n    // initSuccessCallback();\n    this.start();\n  }\n\n  initError(error) {\n    console.log(error);\n    alert('Something went wrong.');\n  }\n\n  start = () => {\n    // video = document.getElementById('video');\n    video = document.createElement('video')\n    video.autoplay = true\n    if (!stream) {\n      throw 'Cannot start after init fail';\n    }\n\n    // streaming takes a moment to start\n    video.addEventListener('canplay', this.startComplete);\n    video.srcObject = stream;\n  }\n\n  startComplete = () => {\n    video.removeEventListener('canplay', this.startComplete);\n    captureInterval = setInterval(this.capture, captureIntervalTime);\n  }\n\n  stop = () => {\n    clearInterval(captureInterval);\n    // video.src = '';\n    // motionContext.clearRect(0, 0, diffWidth, diffHeight);\n    testContext.clearRect(0, 0, diffWidth, diffHeight);\n    isReadyToDiff = false;\n    this.state.stream.getVideoTracks()[0].stop();\n  }\n\n  drawSprites = () => {\n    if(this.props.canvasSprites){\n      this.props.canvasSprites.map(sprite => {\n        const image = new window.Image();\n        image.src = sprite.sprite.url\n        image.onload = () => {\n          testContext.save()\n          // testContext.scale(-1,1)\n          // testContext.drawImage(image, sprite.position.x-test.width+60, sprite.position.y, -60, 60)\n          testContext.drawImage(image,sprite.position.x,sprite.position.y,60,60)\n          testContext.restore()\n        }\n      })\n    }\n\n  }\n\n  capture = () => {\n    // save a full-sized copy of capture\n    captureContext.drawImage(video, 0, 0, captureWidth, captureHeight);\n    let captureImageData = captureContext.getImageData(0, 0, captureWidth, captureHeight);\n    testContext.drawImage(video, 0, 0, captureWidth, captureHeight);\n    this.drawSprites()\n    // diff current capture over previous capture, leftover from last time\n    diffContext.globalCompositeOperation = 'difference';\n    diffContext.drawImage(video, 0, 0, diffWidth, diffHeight);\n    let diffImageData = diffContext.getImageData(0, 0, diffWidth, diffHeight);\n    // console.log('diffImageData',diffImageData)\n\n    if (isReadyToDiff) {\n      let diff = this.processDiff(diffImageData);\n\n      motionContext.putImageData(diffImageData, 0, 0);\n      if (diff.motionBox) {\n        motionContext.strokeStyle = '#fff';\n        motionContext.strokeRect(\n          diff.motionBox.x.min + 0.5,\n          diff.motionBox.y.min + 0.5,\n          diff.motionBox.x.max - diff.motionBox.x.min,\n          diff.motionBox.y.max - diff.motionBox.y.min\n        );\n      }\n      captureCallback({\n        imageData: captureImageData,\n        score: diff.score,\n        hasMotion: diff.score >= scoreThreshold,\n        motionBox: diff.motionBox,\n        motionPixels: diff.motionPixels,\n        getURL: function() {\n          return this.getCaptureUrl(this.imageData);\n        },\n        checkMotionPixel: function(x, y) {\n          return this.checkMotionPixel(this.motionPixels, x, y)\n        }\n      });\n    }\n\n    // draw current capture normally over diff, ready for next time\n    diffContext.globalCompositeOperation = 'source-over';\n    diffContext.drawImage(video, 0, 0, diffWidth, diffHeight);\n    isReadyToDiff = true;\n  }\n\n  processDiff(diffImageData) {\n    let rgba = diffImageData.data;\n\n    // pixel adjustments are done by reference directly on diffImageData\n    let score = 0;\n    let motionPixels = includeMotionPixels ? [] : undefined;\n    let motionBox = undefined;\n    for (let i = 0; i < rgba.length; i += 4) {\n      let pixelDiff = rgba[i] * 0.3 + rgba[i + 1] * 0.6 + rgba[i + 2] * 0.1;\n      let normalized = Math.min(255, pixelDiff * (255 / pixelDiffThreshold));\n      rgba[i] = 0;\n      rgba[i + 1] = normalized;\n      rgba[i + 2] = 0;\n\n      if (pixelDiff >= pixelDiffThreshold) {\n        score++;\n        coords = this.calculateCoordinates(i / 4);\n        console.log('coords', coords, 'pixelDiff',pixelDiff,'i',i)\n        this.props.canvasSprites.map(sprite => {\n          if(sprite.position.x === 0){\n            spritePositionX = 0\n          }else{\n            spritePositionX = (sprite.position.x*diffWidth)/600\n          }\n          if(sprite.position.y === 0){\n            spritePositionY = 0\n          }\n          else{\n            spritePositionY = (sprite.position.y*diffHeight)/450\n          }\n\n          console.log('spritePositionX',spritePositionX,'sprite.position.x',sprite.position.x)\n          console.log('spritePositionY',spritePositionY,'sprite.position.y',sprite.position.y)\n          if(coords.x >= spritePositionX && coords.x <= spritePositionX+10){\n            if(coords.y >= spritePositionY && coords.y <= spritePositionY+6){\n              console.log('%c TOUCHED IT ', 'color: red')\n                if(document.getElementById(sprite.uniqueKey)){\n                  let player = document.getElementById(sprite.uniqueKey)\n                  player.paused ? player.play() : player.pause()\n                }\n              }\n            }\n          })\n\n\n        // if (includeMotionBox) {\n        //   motionBox = this.calculateMotionBox(motionBox, coords.x, coords.y);\n        // }\n        //\n        // if (includeMotionPixels) {\n        //   motionPixels = this.calculateMotionPixels(motionPixels, coords.x, coords.y, pixelDiff);\n        // }\n\n      }\n    }\n\n    return {\n      score: score,\n      motionBox: score > scoreThreshold ? motionBox : undefined,\n      motionPixels: motionPixels\n    };\n  }\n\n  calculateCoordinates(pixelIndex) {\n    return {\n      x: pixelIndex % diffWidth,\n      // y: Math.floor(pixelIndex / diffWidth)\n      y: Math.floor(pixelIndex / diffWidth)\n    };\n  }\n\n  calculateMotionBox(currentMotionBox, x, y) {\n    // init motion box on demand\n    let motionBox = currentMotionBox || {\n      x: {\n        min: coords.x,\n        max: x\n      },\n      y: {\n        min: coords.y,\n        max: y\n      }\n    };\n\n    motionBox.x.min = Math.min(motionBox.x.min, x);\n    motionBox.x.max = Math.max(motionBox.x.max, x);\n    motionBox.y.min = Math.min(motionBox.y.min, y);\n    motionBox.y.max = Math.max(motionBox.y.max, y);\n\n    return motionBox;\n  }\n\n  calculateMotionPixels(motionPixels, x, y, pixelDiff) {\n    motionPixels[x] = motionPixels[x] || [];\n    motionPixels[x][y] = true;\n\n    return motionPixels;\n  }\n\n  getCaptureUrl(captureImageData) {\n    // may as well borrow captureCanvas\n    captureContext.putImageData(captureImageData, 0, 0);\n    return captureCanvas.toDataURL();\n  }\n\n  checkMotionPixel(motionPixels, x, y) {\n    return motionPixels && motionPixels[x] && motionPixels[x][y];\n  }\n\n  getPixelDiffThreshold() {\n    return pixelDiffThreshold;\n  }\n\n  setPixelDiffThreshold(val) {\n    pixelDiffThreshold = val;\n  }\n\n  getScoreThreshold() {\n    return scoreThreshold;\n  }\n\n  setScoreThreshold(val) {\n    scoreThreshold = val;\n  }\n\n  playSound = () => {\n\n  }\n\n  render(){\n    console.log('VIDEO PROPS', this.props)\n    console.log('VIDEO STATE', this.state)\n\n    const videoStyle= {\n      top: 0,\n      left: 0,\n      position: 'absolute',\n      zIndex: 4,\n      // background: 'gray',\n    }\n\n    const motionStyle= {\n      top: this.state.top,\n      left: this.state.left,\n      position: 'absolute',\n      zIndex: -1,\n      // background: 'gray',\n    }\n\n    const testStyle= {\n      top: this.state.top,\n      left: this.state.left,\n      position: 'absolute',\n      zIndex: 4,\n      background: 'black',\n      transform: 'rotateY(180deg)',\n      WebkitTransform:'rotateY(180deg)',\n      MozTransform:'rotateY(180deg)',\n    }\n\n    return(\n      <div>\n        <video id=\"video\" style={videoStyle} width={this.state.width} height={this.state.height} ref='video'></video>\n        <canvas id='motion' style={motionStyle} width={this.state.width} height={this.state.height} ref='motion'/>\n        <canvas id='test' style={testStyle} width={this.state.width} height={this.state.height} ref='test'/>\n        <span id=\"score\"></span>\n        <script src=\"https://webrtc.github.io/adapter/adapter-1.0.7.js\"></script>\n      </div>\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {\n    canvasSprites: state.sprite.canvasSprites,\n    stopVideo: state.sound.stopVideo\n  }\n}\n\nfunction mapDispatchToProps(dispatch){\n  return {}\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Video);\n"]},"metadata":{},"sourceType":"module"}