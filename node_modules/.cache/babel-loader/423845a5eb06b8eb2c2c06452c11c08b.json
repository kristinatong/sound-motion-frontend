{"ast":null,"code":"// export var DiffCamEngine = (function() {\n// \tvar stream;\t\t\t\t\t// stream obtained from webcam\n// \tvar video;\t\t\t\t\t// shows stream\n// \tvar captureCanvas;\t\t\t// internal canvas for capturing full images from video\n// \tvar captureContext;\t\t\t// context for capture canvas\n// \tvar diffCanvas;\t\t\t\t// internal canvas for diffing downscaled captures\n// \tvar diffContext;\t\t\t// context for diff canvas\n// \tvar motionCanvas;\t\t\t// receives processed diff images\n// \tvar motionContext;\t\t\t// context for motion canvas\n//\n// \tvar initSuccessCallback;\t// called when init succeeds\n// \tvar initErrorCallback;\t\t// called when init fails\n// \tvar startCompleteCallback;\t// called when start is complete\n// \tvar captureCallback;\t\t// called when an image has been captured and diffed\n//\n// \tvar captureInterval;\t\t// interval for continuous captures\n// \tvar captureIntervalTime;\t// time between captures, in ms\n// \tvar captureWidth;\t\t\t// full captured image width\n// \tvar captureHeight;\t\t\t// full captured image height\n// \tvar diffWidth;\t\t\t\t// downscaled width for diff/motion\n// \tvar diffHeight;\t\t\t\t// downscaled height for diff/motion\n// \tvar isReadyToDiff;\t\t\t// has a previous capture been made to diff against?\n// \tvar pixelDiffThreshold;\t\t// min for a pixel to be considered significant\n// \tvar scoreThreshold;\t\t\t// min for an image to be considered significant\n// \tvar includeMotionBox;\t\t// flag to calculate and draw motion bounding box\n// \tvar includeMotionPixels;\t// flag to create object denoting pixels with motion\n// \tvar coords;\n// \tvar testContext;\n// \tvar test;\n//\n// \tfunction init(options) {\n// \t\tdebugger\n// \t\t// sanity check\n// \t\tif (!options) {\n// \t\t\tthrow 'No options object provided';\n// \t\t}\n//\n// \t\t// incoming options with defaults\n// \t\tvideo = options.video || document.createElement('video');\n// \t\tmotionCanvas = options.motionCanvas || document.createElement('canvas');\n// \t\tcaptureIntervalTime = options.captureIntervalTime || 100;\n// \t\tcaptureWidth = options.captureWidth || 640;\n// \t\tcaptureHeight = options.captureHeight || 480;\n// \t\tdiffWidth = options.diffWidth || 64;\n// \t\tdiffHeight = options.diffHeight || 48;\n// \t\tpixelDiffThreshold = options.pixelDiffThreshold || 32;\n// \t\tscoreThreshold = options.scoreThreshold || 16;\n// \t\tincludeMotionBox = options.includeMotionBox || false;\n// \t\tincludeMotionPixels = options.includeMotionPixels || false;\n// \t\ttest = options.test || document.createElement('canvas');\n//\n// \t\t// callbacks\n// \t\tinitSuccessCallback = options.initSuccessCallback || function() {};\n// \t\tinitErrorCallback = options.initErrorCallback || function() {};\n// \t\t// startCompleteCallback = options.startCompleteCallback || function() {};\n// \t\tcaptureCallback = options.captureCallback || function() {};\n//\n// \t\t// non-configurable\n// \t\tcaptureCanvas = document.createElement('canvas');\n// \t\tdiffCanvas = document.createElement('canvas');\n// \t\tisReadyToDiff = false;\n//\n// \t\t// prep video\n// \t\tvideo.autoplay = true;\n//\n// \t\t// prep capture canvas\n// \t\tcaptureCanvas.width = captureWidth;\n// \t\tcaptureCanvas.height = captureHeight;\n// \t\tcaptureContext = captureCanvas.getContext('2d');\n//\n// \t\t// prep diff canvas\n// \t\tdiffCanvas.width = diffWidth;\n// \t\tdiffCanvas.height = diffHeight;\n// \t\tdiffContext = diffCanvas.getContext('2d');\n//\n// \t\t// prep motion canvas\n// \t\tmotionCanvas.width = diffWidth;\n// \t\tmotionCanvas.height = diffHeight;\n// \t\tmotionContext = motionCanvas.getContext('2d');\n//\n// \t\t//test canvas\n// \t\ttest.width = diffWidth;\n// \t\ttest.height = diffHeight\n// \t\ttestContext = test.getContext('2d')\n//\n// \t\trequestWebcam();\n// \t}\n//\n// \tfunction requestWebcam() {\n// \t\tvar constraints = {\n// \t\t\taudio: false,\n// \t\t\tvideo: { width: captureWidth, height: captureHeight }\n// \t\t};\n//\n// \t\tnavigator.mediaDevices.getUserMedia(constraints)\n// \t\t\t.then(initSuccess)\n// \t\t\t.catch(initError);\n// \t}\n//\n// \tfunction initSuccess(requestedStream) {\n// \t\tconsole.log(requestedStream)\n// \t\tstream = requestedStream;\n// \t\tconsole.log(initSuccessCallback)\n// \t\tinitSuccessCallback();\n// \t}\n//\n// \tfunction initError(error) {\n// \t\tconsole.log(error);\n// \t\tinitErrorCallback();\n// \t}\n//\n// \tfunction start() {\n// \t\tif (!stream) {\n// \t\t\tthrow 'Cannot start after init fail';\n// \t\t}\n//\n// \t\t// streaming takes a moment to start\n// \t\tvideo.addEventListener('canplay', startComplete);\n// \t\tvideo.srcObject = stream;\n// \t}\n//\n// \tfunction startComplete() {\n// \t\tvideo.removeEventListener('canplay', startComplete);\n// \t\tcaptureInterval = setInterval(capture, captureIntervalTime);\n// \t\t// startCompleteCallback();\n// \t}\n//\n// \tfunction stop() {\n// \t\tclearInterval(captureInterval);\n// \t\tvideo.src = '';\n// \t\tmotionContext.clearRect(0, 0, diffWidth, diffHeight);\n// \t\tisReadyToDiff = false;\n// \t}\n//\n// \tfunction capture() {\n// \t\t// save a full-sized copy of capture\n// \t\tcaptureContext.drawImage(video, 0, 0, captureWidth, captureHeight);\n// \t\tvar captureImageData = captureContext.getImageData(0, 0, captureWidth, captureHeight);\n// \t\ttestContext.drawImage(video,0,0,captureWidth,captureHeight)\n//\n// \t\t// diff current capture over previous capture, leftover from last time\n// \t\tdiffContext.globalCompositeOperation = 'difference';\n// \t\tdiffContext.drawImage(video, 0, 0, diffWidth, diffHeight);\n// \t\tvar diffImageData = diffContext.getImageData(0, 0, diffWidth, diffHeight);\n//\n// \t\tif (isReadyToDiff) {\n// \t\t\tvar diff = processDiff(diffImageData);\n//\n// \t\t\tmotionContext.putImageData(diffImageData, 0, 0);\n// \t\t\tif (diff.motionBox) {\n// \t\t\t\tmotionContext.strokeStyle = '#fff';\n// \t\t\t\tmotionContext.strokeRect(\n// \t\t\t\t\tdiff.motionBox.x.min + 0.5,\n// \t\t\t\t\tdiff.motionBox.y.min + 0.5,\n// \t\t\t\t\tdiff.motionBox.x.max - diff.motionBox.x.min,\n// \t\t\t\t\tdiff.motionBox.y.max - diff.motionBox.y.min\n// \t\t\t\t);\n// \t\t\t}\n//\n//\n// \t\t\tcaptureCallback({\n// \t\t\t\timageData: captureImageData,\n// \t\t\t\tscore: diff.score,\n// \t\t\t\thasMotion: diff.score >= scoreThreshold,\n// \t\t\t\tmotionBox: diff.motionBox,\n// \t\t\t\tmotionPixels: diff.motionPixels,\n// \t\t\t\tgetURL: function() {\n// \t\t\t\t\treturn getCaptureUrl(this.imageData);\n// \t\t\t\t},\n// \t\t\t\tcheckMotionPixel: function(x, y) {\n// \t\t\t\t\treturn checkMotionPixel(this.motionPixels, x, y)\n// \t\t\t\t}\n// \t\t\t});\n// \t\t}\n//\n// \t\t// draw current capture normally over diff, ready for next time\n// \t\tdiffContext.globalCompositeOperation = 'source-over';\n// \t\tdiffContext.drawImage(video, 0, 0, diffWidth, diffHeight);\n// \t\tisReadyToDiff = true;\n// \t}\n//\n// \tfunction processDiff(diffImageData) {\n// \t\tvar rgba = diffImageData.data;\n//\n// \t\t// pixel adjustments are done by reference directly on diffImageData\n// \t\tvar score = 0;\n// \t\tvar motionPixels = includeMotionPixels ? [] : undefined;\n// \t\tvar motionBox = undefined;\n// \t\tfor (var i = 0; i < rgba.length; i += 4) {\n// \t\t\tvar pixelDiff = rgba[i] * 0.3 + rgba[i + 1] * 0.6 + rgba[i + 2] * 0.1;\n// \t\t\tvar normalized = Math.min(255, pixelDiff * (255 / pixelDiffThreshold));\n// \t\t\trgba[i] = 0;\n// \t\t\trgba[i + 1] = normalized;\n// \t\t\trgba[i + 2] = 0;\n//\n// \t\t\tif (pixelDiff >= pixelDiffThreshold) {\n// \t\t\t\tscore++;\n// \t\t\t\tcoords = calculateCoordinates(i / 4);\n//\n// \t\t\t\tif (includeMotionBox) {\n// \t\t\t\t\tmotionBox = calculateMotionBox(motionBox, coords.x, coords.y);\n// \t\t\t\t}\n//\n// \t\t\t\tif (includeMotionPixels) {\n// \t\t\t\t\tmotionPixels = calculateMotionPixels(motionPixels, coords.x, coords.y, pixelDiff);\n// \t\t\t\t}\n//\n// \t\t\t}\n// \t\t}\n//\n// \t\treturn {\n// \t\t\tscore: score,\n// \t\t\tmotionBox: score > scoreThreshold ? motionBox : undefined,\n// \t\t\tmotionPixels: motionPixels\n// \t\t};\n// \t}\n//\n// \tfunction calculateCoordinates(pixelIndex) {\n// \t\treturn {\n// \t\t\tx: pixelIndex % diffWidth,\n// \t\t\ty: Math.floor(pixelIndex / diffWidth)\n// \t\t};\n// \t}\n//\n// \tfunction calculateMotionBox(currentMotionBox, x, y) {\n// \t\t// init motion box on demand\n// \t\tvar motionBox = currentMotionBox || {\n// \t\t\tx: { min: coords.x, max: x },\n// \t\t\ty: { min: coords.y, max: y }\n// \t\t};\n//\n// \t\tmotionBox.x.min = Math.min(motionBox.x.min, x);\n// \t\tmotionBox.x.max = Math.max(motionBox.x.max, x);\n// \t\tmotionBox.y.min = Math.min(motionBox.y.min, y);\n// \t\tmotionBox.y.max = Math.max(motionBox.y.max, y);\n//\n// \t\treturn motionBox;\n// \t}\n//\n// \tfunction calculateMotionPixels(motionPixels, x, y, pixelDiff) {\n// \t\tmotionPixels[x] = motionPixels[x] || [];\n// \t\tmotionPixels[x][y] = true;\n//\n// \t\treturn motionPixels;\n// \t}\n//\n// \tfunction getCaptureUrl(captureImageData) {\n// \t\t// may as well borrow captureCanvas\n// \t\tcaptureContext.putImageData(captureImageData, 0, 0);\n// \t\treturn captureCanvas.toDataURL();\n// \t}\n//\n// \tfunction checkMotionPixel(motionPixels, x, y) {\n// \t\treturn motionPixels && motionPixels[x] && motionPixels[x][y];\n// \t}\n//\n// \tfunction getPixelDiffThreshold() {\n// \t\treturn pixelDiffThreshold;\n// \t}\n//\n// \tfunction setPixelDiffThreshold(val) {\n// \t\tpixelDiffThreshold = val;\n// \t}\n//\n// \tfunction getScoreThreshold() {\n// \t\treturn scoreThreshold;\n// \t}\n//\n// \tfunction setScoreThreshold(val) {\n// \t\tscoreThreshold = val;\n// \t}\n//\n// \treturn {\n// \t\t// public getters/setters\n// \t\tgetPixelDiffThreshold: getPixelDiffThreshold,\n// \t\tsetPixelDiffThreshold: setPixelDiffThreshold,\n// \t\tgetScoreThreshold: getScoreThreshold,\n// \t\tsetScoreThreshold: setScoreThreshold,\n//\n// \t\t// public functions\n// \t\tinit: init,\n// \t\tstart: start,\n// \t\tstop: stop\n// \t};\n// })();","map":{"version":3,"sources":["/Users/kristinatong/projects/sound-motion/sound-motion-frontend/src/components/diff-cam-engine.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// export var DiffCamEngine = (function() {\n// \tvar stream;\t\t\t\t\t// stream obtained from webcam\n// \tvar video;\t\t\t\t\t// shows stream\n// \tvar captureCanvas;\t\t\t// internal canvas for capturing full images from video\n// \tvar captureContext;\t\t\t// context for capture canvas\n// \tvar diffCanvas;\t\t\t\t// internal canvas for diffing downscaled captures\n// \tvar diffContext;\t\t\t// context for diff canvas\n// \tvar motionCanvas;\t\t\t// receives processed diff images\n// \tvar motionContext;\t\t\t// context for motion canvas\n//\n// \tvar initSuccessCallback;\t// called when init succeeds\n// \tvar initErrorCallback;\t\t// called when init fails\n// \tvar startCompleteCallback;\t// called when start is complete\n// \tvar captureCallback;\t\t// called when an image has been captured and diffed\n//\n// \tvar captureInterval;\t\t// interval for continuous captures\n// \tvar captureIntervalTime;\t// time between captures, in ms\n// \tvar captureWidth;\t\t\t// full captured image width\n// \tvar captureHeight;\t\t\t// full captured image height\n// \tvar diffWidth;\t\t\t\t// downscaled width for diff/motion\n// \tvar diffHeight;\t\t\t\t// downscaled height for diff/motion\n// \tvar isReadyToDiff;\t\t\t// has a previous capture been made to diff against?\n// \tvar pixelDiffThreshold;\t\t// min for a pixel to be considered significant\n// \tvar scoreThreshold;\t\t\t// min for an image to be considered significant\n// \tvar includeMotionBox;\t\t// flag to calculate and draw motion bounding box\n// \tvar includeMotionPixels;\t// flag to create object denoting pixels with motion\n// \tvar coords;\n// \tvar testContext;\n// \tvar test;\n//\n// \tfunction init(options) {\n// \t\tdebugger\n// \t\t// sanity check\n// \t\tif (!options) {\n// \t\t\tthrow 'No options object provided';\n// \t\t}\n//\n// \t\t// incoming options with defaults\n// \t\tvideo = options.video || document.createElement('video');\n// \t\tmotionCanvas = options.motionCanvas || document.createElement('canvas');\n// \t\tcaptureIntervalTime = options.captureIntervalTime || 100;\n// \t\tcaptureWidth = options.captureWidth || 640;\n// \t\tcaptureHeight = options.captureHeight || 480;\n// \t\tdiffWidth = options.diffWidth || 64;\n// \t\tdiffHeight = options.diffHeight || 48;\n// \t\tpixelDiffThreshold = options.pixelDiffThreshold || 32;\n// \t\tscoreThreshold = options.scoreThreshold || 16;\n// \t\tincludeMotionBox = options.includeMotionBox || false;\n// \t\tincludeMotionPixels = options.includeMotionPixels || false;\n// \t\ttest = options.test || document.createElement('canvas');\n//\n// \t\t// callbacks\n// \t\tinitSuccessCallback = options.initSuccessCallback || function() {};\n// \t\tinitErrorCallback = options.initErrorCallback || function() {};\n// \t\t// startCompleteCallback = options.startCompleteCallback || function() {};\n// \t\tcaptureCallback = options.captureCallback || function() {};\n//\n// \t\t// non-configurable\n// \t\tcaptureCanvas = document.createElement('canvas');\n// \t\tdiffCanvas = document.createElement('canvas');\n// \t\tisReadyToDiff = false;\n//\n// \t\t// prep video\n// \t\tvideo.autoplay = true;\n//\n// \t\t// prep capture canvas\n// \t\tcaptureCanvas.width = captureWidth;\n// \t\tcaptureCanvas.height = captureHeight;\n// \t\tcaptureContext = captureCanvas.getContext('2d');\n//\n// \t\t// prep diff canvas\n// \t\tdiffCanvas.width = diffWidth;\n// \t\tdiffCanvas.height = diffHeight;\n// \t\tdiffContext = diffCanvas.getContext('2d');\n//\n// \t\t// prep motion canvas\n// \t\tmotionCanvas.width = diffWidth;\n// \t\tmotionCanvas.height = diffHeight;\n// \t\tmotionContext = motionCanvas.getContext('2d');\n//\n// \t\t//test canvas\n// \t\ttest.width = diffWidth;\n// \t\ttest.height = diffHeight\n// \t\ttestContext = test.getContext('2d')\n//\n// \t\trequestWebcam();\n// \t}\n//\n// \tfunction requestWebcam() {\n// \t\tvar constraints = {\n// \t\t\taudio: false,\n// \t\t\tvideo: { width: captureWidth, height: captureHeight }\n// \t\t};\n//\n// \t\tnavigator.mediaDevices.getUserMedia(constraints)\n// \t\t\t.then(initSuccess)\n// \t\t\t.catch(initError);\n// \t}\n//\n// \tfunction initSuccess(requestedStream) {\n// \t\tconsole.log(requestedStream)\n// \t\tstream = requestedStream;\n// \t\tconsole.log(initSuccessCallback)\n// \t\tinitSuccessCallback();\n// \t}\n//\n// \tfunction initError(error) {\n// \t\tconsole.log(error);\n// \t\tinitErrorCallback();\n// \t}\n//\n// \tfunction start() {\n// \t\tif (!stream) {\n// \t\t\tthrow 'Cannot start after init fail';\n// \t\t}\n//\n// \t\t// streaming takes a moment to start\n// \t\tvideo.addEventListener('canplay', startComplete);\n// \t\tvideo.srcObject = stream;\n// \t}\n//\n// \tfunction startComplete() {\n// \t\tvideo.removeEventListener('canplay', startComplete);\n// \t\tcaptureInterval = setInterval(capture, captureIntervalTime);\n// \t\t// startCompleteCallback();\n// \t}\n//\n// \tfunction stop() {\n// \t\tclearInterval(captureInterval);\n// \t\tvideo.src = '';\n// \t\tmotionContext.clearRect(0, 0, diffWidth, diffHeight);\n// \t\tisReadyToDiff = false;\n// \t}\n//\n// \tfunction capture() {\n// \t\t// save a full-sized copy of capture\n// \t\tcaptureContext.drawImage(video, 0, 0, captureWidth, captureHeight);\n// \t\tvar captureImageData = captureContext.getImageData(0, 0, captureWidth, captureHeight);\n// \t\ttestContext.drawImage(video,0,0,captureWidth,captureHeight)\n//\n// \t\t// diff current capture over previous capture, leftover from last time\n// \t\tdiffContext.globalCompositeOperation = 'difference';\n// \t\tdiffContext.drawImage(video, 0, 0, diffWidth, diffHeight);\n// \t\tvar diffImageData = diffContext.getImageData(0, 0, diffWidth, diffHeight);\n//\n// \t\tif (isReadyToDiff) {\n// \t\t\tvar diff = processDiff(diffImageData);\n//\n// \t\t\tmotionContext.putImageData(diffImageData, 0, 0);\n// \t\t\tif (diff.motionBox) {\n// \t\t\t\tmotionContext.strokeStyle = '#fff';\n// \t\t\t\tmotionContext.strokeRect(\n// \t\t\t\t\tdiff.motionBox.x.min + 0.5,\n// \t\t\t\t\tdiff.motionBox.y.min + 0.5,\n// \t\t\t\t\tdiff.motionBox.x.max - diff.motionBox.x.min,\n// \t\t\t\t\tdiff.motionBox.y.max - diff.motionBox.y.min\n// \t\t\t\t);\n// \t\t\t}\n//\n//\n// \t\t\tcaptureCallback({\n// \t\t\t\timageData: captureImageData,\n// \t\t\t\tscore: diff.score,\n// \t\t\t\thasMotion: diff.score >= scoreThreshold,\n// \t\t\t\tmotionBox: diff.motionBox,\n// \t\t\t\tmotionPixels: diff.motionPixels,\n// \t\t\t\tgetURL: function() {\n// \t\t\t\t\treturn getCaptureUrl(this.imageData);\n// \t\t\t\t},\n// \t\t\t\tcheckMotionPixel: function(x, y) {\n// \t\t\t\t\treturn checkMotionPixel(this.motionPixels, x, y)\n// \t\t\t\t}\n// \t\t\t});\n// \t\t}\n//\n// \t\t// draw current capture normally over diff, ready for next time\n// \t\tdiffContext.globalCompositeOperation = 'source-over';\n// \t\tdiffContext.drawImage(video, 0, 0, diffWidth, diffHeight);\n// \t\tisReadyToDiff = true;\n// \t}\n//\n// \tfunction processDiff(diffImageData) {\n// \t\tvar rgba = diffImageData.data;\n//\n// \t\t// pixel adjustments are done by reference directly on diffImageData\n// \t\tvar score = 0;\n// \t\tvar motionPixels = includeMotionPixels ? [] : undefined;\n// \t\tvar motionBox = undefined;\n// \t\tfor (var i = 0; i < rgba.length; i += 4) {\n// \t\t\tvar pixelDiff = rgba[i] * 0.3 + rgba[i + 1] * 0.6 + rgba[i + 2] * 0.1;\n// \t\t\tvar normalized = Math.min(255, pixelDiff * (255 / pixelDiffThreshold));\n// \t\t\trgba[i] = 0;\n// \t\t\trgba[i + 1] = normalized;\n// \t\t\trgba[i + 2] = 0;\n//\n// \t\t\tif (pixelDiff >= pixelDiffThreshold) {\n// \t\t\t\tscore++;\n// \t\t\t\tcoords = calculateCoordinates(i / 4);\n//\n// \t\t\t\tif (includeMotionBox) {\n// \t\t\t\t\tmotionBox = calculateMotionBox(motionBox, coords.x, coords.y);\n// \t\t\t\t}\n//\n// \t\t\t\tif (includeMotionPixels) {\n// \t\t\t\t\tmotionPixels = calculateMotionPixels(motionPixels, coords.x, coords.y, pixelDiff);\n// \t\t\t\t}\n//\n// \t\t\t}\n// \t\t}\n//\n// \t\treturn {\n// \t\t\tscore: score,\n// \t\t\tmotionBox: score > scoreThreshold ? motionBox : undefined,\n// \t\t\tmotionPixels: motionPixels\n// \t\t};\n// \t}\n//\n// \tfunction calculateCoordinates(pixelIndex) {\n// \t\treturn {\n// \t\t\tx: pixelIndex % diffWidth,\n// \t\t\ty: Math.floor(pixelIndex / diffWidth)\n// \t\t};\n// \t}\n//\n// \tfunction calculateMotionBox(currentMotionBox, x, y) {\n// \t\t// init motion box on demand\n// \t\tvar motionBox = currentMotionBox || {\n// \t\t\tx: { min: coords.x, max: x },\n// \t\t\ty: { min: coords.y, max: y }\n// \t\t};\n//\n// \t\tmotionBox.x.min = Math.min(motionBox.x.min, x);\n// \t\tmotionBox.x.max = Math.max(motionBox.x.max, x);\n// \t\tmotionBox.y.min = Math.min(motionBox.y.min, y);\n// \t\tmotionBox.y.max = Math.max(motionBox.y.max, y);\n//\n// \t\treturn motionBox;\n// \t}\n//\n// \tfunction calculateMotionPixels(motionPixels, x, y, pixelDiff) {\n// \t\tmotionPixels[x] = motionPixels[x] || [];\n// \t\tmotionPixels[x][y] = true;\n//\n// \t\treturn motionPixels;\n// \t}\n//\n// \tfunction getCaptureUrl(captureImageData) {\n// \t\t// may as well borrow captureCanvas\n// \t\tcaptureContext.putImageData(captureImageData, 0, 0);\n// \t\treturn captureCanvas.toDataURL();\n// \t}\n//\n// \tfunction checkMotionPixel(motionPixels, x, y) {\n// \t\treturn motionPixels && motionPixels[x] && motionPixels[x][y];\n// \t}\n//\n// \tfunction getPixelDiffThreshold() {\n// \t\treturn pixelDiffThreshold;\n// \t}\n//\n// \tfunction setPixelDiffThreshold(val) {\n// \t\tpixelDiffThreshold = val;\n// \t}\n//\n// \tfunction getScoreThreshold() {\n// \t\treturn scoreThreshold;\n// \t}\n//\n// \tfunction setScoreThreshold(val) {\n// \t\tscoreThreshold = val;\n// \t}\n//\n// \treturn {\n// \t\t// public getters/setters\n// \t\tgetPixelDiffThreshold: getPixelDiffThreshold,\n// \t\tsetPixelDiffThreshold: setPixelDiffThreshold,\n// \t\tgetScoreThreshold: getScoreThreshold,\n// \t\tsetScoreThreshold: setScoreThreshold,\n//\n// \t\t// public functions\n// \t\tinit: init,\n// \t\tstart: start,\n// \t\tstop: stop\n// \t};\n// })();\n"]},"metadata":{},"sourceType":"module"}