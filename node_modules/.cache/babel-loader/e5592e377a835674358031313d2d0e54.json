{"ast":null,"code":"// adapted FROM: https://github.com/facebook/react/blob/3019210df2b486416ed94d7b9becffaf254e81c4/src/renderers/shared/ReactDOMFrameScheduling.js\n'use strict'; // This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar hasNativePerformanceNow = (typeof performance === 'undefined' ? 'undefined' : _typeof(performance)) === 'object' && typeof performance.now === 'function';\nvar now = void 0;\n\nif (hasNativePerformanceNow) {\n  now = function now() {\n    return performance.now();\n  };\n} else {\n  now = function now() {\n    return Date.now();\n  };\n} // TODO: There's no way to cancel, because Fiber doesn't atm.\n\n\nvar rIC = void 0;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  rIC = function rIC(frameCallback) {\n    setTimeout(function () {\n      frameCallback({\n        timeRemaining: function timeRemaining() {\n          return Infinity;\n        }\n      });\n    });\n    return 0;\n  };\n} else if (typeof requestIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback.\n  var scheduledRAFCallback = null;\n  var scheduledRICCallback = null;\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n  var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n  var frameDeadlineObject;\n\n  if (hasNativePerformanceNow) {\n    frameDeadlineObject = {\n      timeRemaining: function timeRemaining() {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        return frameDeadline - performance.now();\n      }\n    };\n  } else {\n    frameDeadlineObject = {\n      timeRemaining: function timeRemaining() {\n        // Fallback to Date.now()\n        return frameDeadline - Date.now();\n      }\n    };\n  } // We use the postMessage trick to defer idle work until after the repaint.\n\n\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n\n  var idleTick = function idleTick(event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n    var callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n\n    if (callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  }; // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n\n\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function animationTick(rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      } // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n\n\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n\n    frameDeadline = rafTime + activeFrameTime;\n\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n\n    var callback = scheduledRAFCallback;\n    scheduledRAFCallback = null;\n\n    if (callback !== null) {\n      callback(rafTime);\n    }\n  };\n\n  rIC = function rIC(callback) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n\n    return 0;\n  };\n} else {\n  rIC = requestIdleCallback;\n}\n\nexports.now = now;\nexports.rIC = rIC;","map":null,"metadata":{},"sourceType":"script"}