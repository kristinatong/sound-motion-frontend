{"ast":null,"code":"/**\n * Based on ReactArt.js\n * Copyright (c) 2017-present Lavrenov Anton.\n * All rights reserved.\n *\n * MIT\n */\n'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar emptyObject = require('fbjs/lib/emptyObject');\n\nvar React = require('react');\n\nvar Konva = require('konva');\n\nvar ReactFiberReconciler = require('react-reconciler');\n\nvar ReactDOMFrameScheduling = require('./ReactDOMFrameScheduling');\n\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\n\nvar Component = React.Component;\nvar EVENTS_NAMESPACE = '.react-konva-event';\nvar propsToSkip = {\n  children: true,\n  ref: true,\n  key: true,\n  style: true\n};\nvar idWarningShowed = false;\nvar zIndexWarningShowed = false;\nvar useStrictMode = false;\n\nfunction toggleStrictMode(value) {\n  useStrictMode = value;\n}\n\nfunction applyNodeProps(instance, props) {\n  var oldProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!idWarningShowed && 'id' in props) {\n    var message = 'ReactKonva: You are using \"id\" attribute for a Konva node. In some very rare cases it may produce bugs. Currently we recommend not to use it and use \"name\" attribute instead.\\nYou are using id = \"' + props.id + '\".\\nFor me info see: https://github.com/konvajs/react-konva/issues/119';\n    console.warn(message);\n    idWarningShowed = true;\n  }\n\n  if (!zIndexWarningShowed && 'zIndex' in props) {\n    var _message = 'ReactKonva: You are using \"zIndex\" attribute for a Konva node.\\nreact-konva may get confused with ordering. Just define correct order of elements in your render function of a component.\\nFor me info see: https://github.com/konvajs/react-konva/issues/194\\n';\n    console.warn(_message);\n    zIndexWarningShowed = true;\n  }\n\n  var updatedProps = {};\n  var hasUpdates = false;\n\n  for (var key in oldProps) {\n    if (propsToSkip[key]) {\n      continue;\n    }\n\n    var isEvent = key.slice(0, 2) === 'on';\n    var propChanged = oldProps[key] !== props[key];\n\n    if (isEvent && propChanged) {\n      var eventName = key.substr(2).toLowerCase();\n\n      if (eventName.substr(0, 7) === 'content') {\n        eventName = 'content' + eventName.substr(7, 1).toUpperCase() + eventName.substr(8);\n      }\n\n      instance.off(eventName, oldProps[key]);\n    }\n\n    var toRemove = !props.hasOwnProperty(key);\n\n    if (toRemove) {\n      instance.setAttr(key, undefined);\n    }\n  }\n\n  for (var key in props) {\n    if (propsToSkip[key]) {\n      continue;\n    }\n\n    var isEvent = key.slice(0, 2) === 'on';\n    var toAdd = oldProps[key] !== props[key];\n\n    if (isEvent && toAdd) {\n      var eventName = key.substr(2).toLowerCase();\n\n      if (eventName.substr(0, 7) === 'content') {\n        eventName = 'content' + eventName.substr(7, 1).toUpperCase() + eventName.substr(8);\n      }\n\n      if (props[key]) {\n        instance.on(eventName + EVENTS_NAMESPACE, props[key]);\n      }\n    }\n\n    if (!isEvent && (props[key] !== oldProps[key] || useStrictMode && props[key] !== instance.getAttr(key))) {\n      hasUpdates = true;\n      updatedProps[key] = props[key];\n    }\n  }\n\n  if (hasUpdates) {\n    instance.setAttrs(updatedProps);\n    updatePicture(instance);\n  }\n}\n\nfunction updatePicture(node) {\n  var drawingNode = node.getLayer() || node.getStage();\n  drawingNode && drawingNode.batchDraw();\n}\n\nvar Stage = function (_Component) {\n  _inherits(Stage, _Component);\n\n  function Stage() {\n    _classCallCheck(this, Stage);\n\n    return _possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  Stage.prototype.componentDidMount = function componentDidMount() {\n    if (!Konva.isBrowser) {\n      return;\n    }\n\n    this._stage = new Konva.Stage({\n      width: this.props.width,\n      height: this.props.height,\n      container: this._tagRef\n    });\n    applyNodeProps(this._stage, this.props);\n    this._mountNode = KonvaRenderer.createContainer(this._stage);\n    KonvaRenderer.updateContainer(this.props.children, this._mountNode, this);\n  };\n\n  Stage.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    if (!Konva.isBrowser) {\n      return;\n    }\n\n    applyNodeProps(this._stage, this.props, prevProps);\n    KonvaRenderer.updateContainer(this.props.children, this._mountNode, this);\n  };\n\n  Stage.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (!Konva.isBrowser) {\n      return;\n    }\n\n    KonvaRenderer.updateContainer(null, this._mountNode, this);\n\n    this._stage.destroy();\n  };\n\n  Stage.prototype.getStage = function getStage() {\n    return this._stage;\n  };\n\n  Stage.prototype.render = function render() {\n    var _this2 = this;\n\n    var props = this.props;\n    return React.createElement('div', {\n      ref: function ref(_ref) {\n        return _this2._tagRef = _ref;\n      },\n      accessKey: props.accessKey,\n      className: props.className,\n      role: props.role,\n      style: props.style,\n      tabIndex: props.tabIndex,\n      title: props.title\n    });\n  };\n\n  return Stage;\n}(Component);\n\nvar KONVA_NODES = ['Layer', 'FastLayer', 'Group', 'Label', 'Rect', 'Circle', 'Ellipse', 'Wedge', 'Line', 'Sprite', 'Image', 'Text', 'TextPath', 'Star', 'Ring', 'Arc', 'Tag', 'Path', 'RegularPolygon', 'Arrow', 'Shape', 'Transformer'];\nvar TYPES = {};\nKONVA_NODES.forEach(function (nodeName) {\n  TYPES[nodeName] = nodeName;\n});\nvar UPDATE_SIGNAL = {};\nvar KonvaRenderer = ReactFiberReconciler({\n  appendInitialChild: function appendInitialChild(parentInstance, child) {\n    if (typeof child === 'string') {\n      // Noop for string children of Text (eg <Text>{'foo'}{'bar'}</Text>)\n      invariant(false, 'Don not use plain text as child of Konva.Node. You are using text: \"%s\"', child);\n      return;\n    }\n\n    parentInstance.add(child);\n    updatePicture(parentInstance);\n  },\n  createInstance: function createInstance(type, props, internalInstanceHandle) {\n    var NodeClass = Konva[type];\n\n    if (!NodeClass) {\n      invariant(instance, 'ReactKonva does not support the type \"%s\". If you want to render DOM elements as part of canvas tree take a look into this demo: https://konvajs.github.io/docs/react/DOM_Portal.html', type);\n      return;\n    }\n\n    var instance = new NodeClass();\n    instance._applyProps = applyNodeProps;\n\n    instance._applyProps(instance, props);\n\n    return instance;\n  },\n  createTextInstance: function createTextInstance(text, rootContainerInstance, internalInstanceHandle) {\n    invariant(false, 'Text components are not supported for now in ReactKonva. You text is: \"' + text + '\"');\n  },\n  finalizeInitialChildren: function finalizeInitialChildren(domElement, type, props) {\n    return false;\n  },\n  getPublicInstance: function getPublicInstance(instance) {\n    return instance;\n  },\n  prepareForCommit: function prepareForCommit() {// Noop\n  },\n  prepareUpdate: function prepareUpdate(domElement, type, oldProps, newProps) {\n    return UPDATE_SIGNAL;\n  },\n  resetAfterCommit: function resetAfterCommit() {// Noop\n  },\n  resetTextContent: function resetTextContent(domElement) {// Noop\n  },\n  shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(type, props) {\n    return false;\n  },\n  getRootHostContext: function getRootHostContext() {\n    return emptyObject;\n  },\n  getChildHostContext: function getChildHostContext() {\n    return emptyObject;\n  },\n  scheduleDeferredCallback: ReactDOMFrameScheduling.rIC,\n  shouldSetTextContent: function shouldSetTextContent(type, props) {\n    return false;\n  },\n  // cancelDeferredCallback: ReactScheduler.cancelDeferredCallback,\n  now: ReactDOMFrameScheduling.now,\n  // The Konva renderer is secondary to the React DOM renderer.\n  isPrimaryRenderer: false,\n  supportsMutation: true,\n  // useSyncScheduling: true,\n  appendChild: function appendChild(parentInstance, child) {\n    if (child.parent === parentInstance) {\n      child.moveToTop();\n    } else {\n      parentInstance.add(child);\n    }\n\n    updatePicture(parentInstance);\n  },\n  appendChildToContainer: function appendChildToContainer(parentInstance, child) {\n    if (child.parent === parentInstance) {\n      child.moveToTop();\n    } else {\n      parentInstance.add(child);\n    }\n\n    updatePicture(parentInstance);\n  },\n  insertBefore: function insertBefore(parentInstance, child, beforeChild) {\n    invariant(child !== beforeChild, 'ReactKonva: Can not insert node before itself'); // remove and add back to reset zIndex\n\n    child.remove();\n    parentInstance.add(child);\n    child.setZIndex(beforeChild.getZIndex());\n    updatePicture(parentInstance);\n  },\n  insertInContainerBefore: function insertInContainerBefore(parentInstance, child, beforeChild) {\n    invariant(child !== beforeChild, 'ReactKonva: Can not insert node before itself'); // remove and add back to reset zIndex\n\n    child.remove();\n    parentInstance.add(child);\n    child.setZIndex(beforeChild.getZIndex());\n    updatePicture(parentInstance);\n  },\n  removeChild: function removeChild(parentInstance, child) {\n    child.destroy();\n    child.off(EVENTS_NAMESPACE);\n    updatePicture(parentInstance);\n  },\n  removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {\n    child.destroy();\n    child.off(EVENTS_NAMESPACE);\n    updatePicture(parentInstance);\n  },\n  commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {\n    invariant(false, 'Text components are not yet supported in ReactKonva. You text is: \"' + newText + '\"');\n  },\n  commitMount: function commitMount(instance, type, newProps) {// Noop\n  },\n  commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n    instance._applyProps(instance, newProps, oldProps);\n  }\n});\nKonvaRenderer.injectIntoDevTools({\n  findFiberByHostInstance: ReactDOMComponentTree.getClosestInstanceFromNode,\n  bundleType: process.env.NODE_ENV !== 'production' ? 1 : 0,\n  version: React.version || 16,\n  rendererPackageName: 'react-konva',\n  getInspectorDataForViewTag: function getInspectorDataForViewTag() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    console.log(args);\n  }\n});\n/** API */\n\nmodule.exports = _extends({}, TYPES, {\n  Stage: Stage,\n  useStrictMode: toggleStrictMode\n});","map":null,"metadata":{},"sourceType":"script"}